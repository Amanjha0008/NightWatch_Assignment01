"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NightwatchAllureReporter = exports.allure = void 0;
const AllureReporter_1 = require("./AllureReporter");
const fs_1 = __importDefault(require("fs"));
const allure_js_commons_1 = require("allure-js-commons");
const allure_js_commons_2 = require("allure-js-commons");
class NightwatchAllureReporter {
    constructor(opts) {
        this.sendData = false;
        const folderName = opts && opts.folder ? opts.folder : "allure-results";
        const sendData = opts && opts.sendData ? opts.sendData : false;
        const allureConfig = { resultsDir: folderName };
        if (sendData)
            this.sendData = true;
        this.coreReporter = new AllureReporter_1.AllureReporter(new allure_js_commons_1.AllureRuntime(allureConfig));
        exports.allure = this.coreReporter.getInterface();
    }
    write(results, done) {
        let suiteStatus = allure_js_commons_2.Status.BROKEN;
        let testCount = 0;
        let passedCount = 0;
        let failedCount = 0;
        let skippedCount = 0;
        let partialCount = 0;
        for (let currentModuleName in results.modules) {
            testCount++;
            let currentModule = results.modules[currentModuleName];
            let currentTest = {
                reportPrefix: currentModule.reportPrefix,
                failures: currentModule.failures,
                errors: currentModule.errors,
                skipped: currentModule.skipped.length,
                tests: currentModule.tests,
                isFailure: currentModule.failures > 0 || currentModule.errors > 0,
                isSkipped: currentModule.skipped.length === currentModule.tests,
                suiteName: currentModule.group,
                testName: currentModuleName,
                testSteps: [],
                errorMessage: "",
                timeMs: parseFloat(currentModule.time) * 1000,
                tags: {}
            };
            if (currentTest.suiteName === "") {
                currentTest.suiteName = currentTest.testName;
            }
            if (results.environment !== "") {
                currentTest.suiteName =
                    currentTest.suiteName + "-" + results.environment;
            }
            this.coreReporter.startSuite(currentTest.suiteName);
            this.coreReporter.startCase(currentTest);
            exports.allure.attachment("Reported Result", JSON.stringify(currentModule), allure_js_commons_2.ContentType.JSON);
            for (let completedStep in currentModule.completed) {
                let step = exports.allure.startStep(completedStep);
                const currentStep = currentModule.completed[completedStep];
                if (currentStep.tests === currentStep.passed) {
                    step.setStatus(allure_js_commons_2.Status.PASSED);
                }
                else if (currentStep.tests === currentStep.skipped) {
                    step.setStatus(allure_js_commons_2.Status.SKIPPED);
                }
                else if (currentStep.tests === currentStep.failed) {
                    step.setStatus(allure_js_commons_2.Status.FAILED);
                    step.setDetailsTrace(currentStep.stackTrace);
                }
                else {
                    step.setStatus(allure_js_commons_2.Status.BROKEN);
                    step.setDetailsTrace(currentStep.stackTrace);
                }
                for (let completedAssertion in currentStep.assertions) {
                    const currentAssertion = currentStep.assertions[completedAssertion];
                    let assertion = exports.allure.startStep(currentAssertion.message);
                    assertion.setDescription(currentAssertion.fullMsg);
                    if (currentAssertion.failure) {
                        assertion.setStatus(allure_js_commons_2.Status.FAILED);
                        assertion.setDetailsTrace(currentAssertion.stackTrace);
                    }
                    else {
                        assertion.setStatus(allure_js_commons_2.Status.PASSED);
                    }
                    if (currentAssertion.screenshots && currentAssertion.screenshots.length > 0) {
                        for (let index in currentAssertion.screenshots) {
                            const file = currentAssertion.screenshots[index];
                            const data = fs_1.default.readFileSync(file);
                            exports.allure.attachment("Screenshot", data, allure_js_commons_2.ContentType.PNG);
                        }
                    }
                    assertion.endStep();
                }
                step.endStep(currentStep.timeMs);
            }
            for (let skippedStep in currentModule.skipped) {
                let step = exports.allure.startStep(skippedStep);
                step.setStatus(allure_js_commons_2.Status.SKIPPED);
                step.endStep();
            }
            if (currentTest.isFailure) {
                this.coreReporter.setTestStatus(allure_js_commons_2.Status.FAILED);
            }
            else if (currentTest.isSkipped) {
                this.coreReporter.setTestStatus(allure_js_commons_2.Status.SKIPPED);
            }
            else {
                this.coreReporter.setTestStatus(allure_js_commons_2.Status.PASSED);
            }
            if (currentModule.errmessages && currentModule.errmessages.length > 0)
                this.coreReporter.setTestDetailsTrace(currentModule.errmessages.join(","));
            this.coreReporter.completeTest();
            this.coreReporter.endSuite();
        }
        done();
    }
}
exports.NightwatchAllureReporter = NightwatchAllureReporter;
//# sourceMappingURL=NightwatchAllureReporter.js.map